package org.vitrivr.cottontail.dbms.execution.operators.predicates

import kotlinx.coroutines.flow.Flow
import kotlinx.coroutines.flow.flow
import org.vitrivr.cottontail.core.basics.Record
import org.vitrivr.cottontail.core.database.ColumnDef
import org.vitrivr.cottontail.core.queries.binding.Binding
import org.vitrivr.cottontail.core.queries.binding.MissingRecord
import org.vitrivr.cottontail.core.queries.predicates.BooleanPredicate
import org.vitrivr.cottontail.core.queries.predicates.ComparisonOperator
import org.vitrivr.cottontail.dbms.execution.operators.basics.Operator
import org.vitrivr.cottontail.dbms.execution.operators.basics.take
import org.vitrivr.cottontail.dbms.queries.context.QueryContext

/**
 * An [Operator.MergingPipelineOperator] used during query execution.
 *
 * It filters the input generated by the parent [Operator] using the given [BooleanPredicate]. Depends on prior execution
 * of the provided [subquery] [Operator]s.
 *
 * @author Ralph Gasser
 * @version 2.0.0
 */
class FilterOnSubselectOperator(val parent: Operator, val subquery: Operator, val predicate: BooleanPredicate, override val context: QueryContext) : Operator.MergingPipelineOperator(listOf(parent, subquery)) {

    /** This is technically a pipeline breaker because it has to wait for the completion of the sub-SELECTS. */
    override val breaker: Boolean = true

    /** The [ColumnDef] generated by this [FilterOnSubselectOperator]. */
    override val columns: List<ColumnDef<*>>
        get() = this.parent.columns

    /**
     * Converts this [FilterOnSubselectOperator] to a [Flow] and returns it.
     *
     * @return [Flow] representing this [FilterOnSubselectOperator]
     */
    override fun toFlow(): Flow<Record> = flow {
        /* Prepare main branch of query execution + sub-select branches. */
        val query = this@FilterOnSubselectOperator.parent.toFlow()
        val subqueryFlow = this@FilterOnSubselectOperator.subquery.toFlow()
        with(this@FilterOnSubselectOperator.context.bindings) {
            with(MissingRecord) {
                for (a in this@FilterOnSubselectOperator.predicate.atomics) {
                    /* Case 1: Binary operator that depends on sub-query. */
                    val op = a.operator
                    if (op is ComparisonOperator.Binary) {
                        /* Case 1a: Left-hand side depends on sub-query. */
                        val subquery = if (op.left is Binding.Subquery) {
                            op.left as Binding.Subquery
                        } else if (op.right is Binding.Subquery) {
                            op.right as Binding.Subquery
                        } else {
                            throw IllegalStateException("Encountered FilterOnSubSelectOperator without Sub-Select query. This is a programmer's error!")
                        }
                        subqueryFlow.take(1L).collect {
                            val value = it[subquery.column]
                            if (value != null) {
                                (op.left as Binding.Subquery).append(value)
                            }
                        }
                    }

                    /* Case 2: IN operator that depends on sub-query. */
                    if (op is ComparisonOperator.In) {
                        for (b in op.right) {
                            if (b is Binding.Subquery) {
                                subqueryFlow.collect {
                                    val value = it[0]
                                    if (value != null) b.append(value)
                                }
                            }
                        }
                    }
                }
            }

            /* Stage 2: Make with materialis */
            this@FilterOnSubselectOperator.predicate.prepare()
            query.collect { record ->
                with(record) {
                    if (this@FilterOnSubselectOperator.predicate.isMatch()) {
                        emit(this)
                    }
                }
            }
        }
    }
}