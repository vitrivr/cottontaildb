package org.vitrivr.cottontail.core.queries.binding

import org.vitrivr.cottontail.core.database.ColumnDef
import org.vitrivr.cottontail.core.queries.Digest
import org.vitrivr.cottontail.core.queries.GroupId
import org.vitrivr.cottontail.core.queries.nodes.BindableNode
import org.vitrivr.cottontail.core.queries.nodes.CopyableNode
import org.vitrivr.cottontail.core.queries.nodes.NodeWithCost
import org.vitrivr.cottontail.core.queries.planning.cost.Cost
import org.vitrivr.cottontail.core.values.types.Types
import org.vitrivr.cottontail.core.values.types.Value

/**
 * This class acts as a level of indirection for [Value]'s used during query planning, optimization and execution.
 *
 * @author Ralph Gasser
 * @version 1.6.0
 */
sealed interface Binding: BindableNode, CopyableNode, NodeWithCost {

    /** The bound [Value]. */
    val value: Value?

    /** The [Types] held by this [Binding]. */
    val type: Types<*>

    /** Flag indicating whether [Binding] can return a NULL value. */
    val canBeNull: Boolean

    /** Flag indicating whether [Binding] remains static in the context of a query. */
    val static: Boolean

    /** The [BindingContext] associated with this [Binding]. */
    val context: BindingContext

    /**
     * Copies this [Binding], creating a new [Binding] that is initially bound to the same [BindingContext].
     *
     * @return Copy of this [Binding]
     */
    override fun copy(): Binding

    /**
     *
     */
    override fun digest(): Digest = this.hashCode().toLong()

    /** A [Binding] for a literal [Value] without any indirection other than the [Binding] itself. */
    data class Literal(val bindingIndex: Int, override val static: Boolean, override val canBeNull: Boolean, override val type: Types<*>, override var context: BindingContext): Binding {
        override val value: Value?
            get() = this.context[this]
        override val cost: Cost
            get() = Cost.MEMORY_ACCESS
        override fun copy() = Literal(this.bindingIndex, this.static, this.canBeNull, this.type, this.context)
        override fun bind(context: BindingContext) {
            this.context = context
        }
        fun update(value: Value?) = this.context.update(this, value)
        override fun toString(): String = ":$bindingIndex"
    }

    /**
     * A [Binding] for a [Value] referred to by a [ColumnDef].
     *
     * Can only be accessed during query execution.
     */
    data class Column(val column: ColumnDef<*>, override var context: BindingContext): Binding  {
        override val value: Value?
            get() = this.context[this]
        override val type: Types<*>
            get() = this.column.type
        override val canBeNull: Boolean
            get() = this.column.nullable
        override val static: Boolean
            get() = false
        override val cost: Cost
            get() = Cost.MEMORY_ACCESS
        override fun copy() = Column(this.column, this.context)
        override fun bind(context: BindingContext) {
            this.context = context
        }
        override fun toString(): String = "${this.column.name}"
    }

    /**
     * A [Binding] for a value generated by invocation of a [org.vitrivr.cottontail.core.queries.functions.Function].
     *
     * Can only be accessed during query execution.
     */
    data class Function(val bindingIndex: Int, val function: org.vitrivr.cottontail.core.queries.functions.Function<*>, val arguments: List<Binding>, override var context: BindingContext): Binding {
        init {
            this.function.signature.arguments.forEachIndexed {  i, arg ->
                check(arg.type == this.arguments[i].type) { "Type ${this.arguments[i].type} of argument $i is incompatible with function ${function.signature}." }
            }
        }

        override val value: Value?
            get() = this.context[this]
        override val type: Types<*>
            get() = this.function.signature.returnType
        override val canBeNull: Boolean
            get() = this.arguments.any { it.canBeNull }
        override val cost: Cost
            get() = this.function.cost + this.arguments.map { it.cost }.reduce { c1, c2 -> c1 + c2}
        override val static: Boolean
            get() = false
        val executable: Boolean
            get() = this.function.executable

        override fun copy() = Function(this.bindingIndex, this.function.copy(), this.arguments.map { it.copy() }, this.context)
        override fun bind(context: BindingContext) {
            this.context = context
            this.arguments.forEach { it.bind(context) }
        }
        override fun toString(): String = "${this.function.signature}"

        /**
         * Tries to resolve all [ColumnDef] that are required by this [Binding.Function] and possible sub-functions.
         *
         * @return List of required [ColumnDef].
         */
        fun requiredColumns(): List<ColumnDef<*>> = this.arguments.flatMap {
            val columns = mutableSetOf<ColumnDef<*>>()
            when (it) {
                is Column -> columns.add(it.column)
                is Function -> columns.addAll(it.requiredColumns())
                else -> {}
            }
            columns.toList()
        }
    }

    /**
     * A [Binding] for one or multiple [Value]s generated by invocation of a sub-query.
     *
     * Can only be accessed during query execution.
     */
    data class Subquery(val dependsOn: GroupId, val column: ColumnDef<*>, override var context: BindingContext): Binding {
        override val value: Value?
            get() = this.values.firstOrNull()
        val values: Collection<Value?>
            get() = this.context[this]
        override val type: Types<*>
            get() = this.column.type
        override val canBeNull: Boolean
            get() = this.column.nullable
        override val static: Boolean
            get() = false
        override val cost: Cost
            get() = Cost.ZERO
        override fun copy() = Subquery(this.dependsOn, this.column, this.context)
        override fun bind(context: BindingContext) {
            this.context = context
        }

        /**
         * Appends a [Value] to this [Subquery] in the provided [BindingContext].
         *
         * @param value The [Value] to append.
         */
        fun append(value: Value) = this.context.append(this, value)

        /**
         * Clears all [Value]s bound to this [Subquery] within the provided [BindingContext].
         */
        fun clear() = this.context.clear(this)
    }
}