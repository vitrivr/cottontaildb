package org.vitrivr.cottontail.core.queries.binding

import org.vitrivr.cottontail.core.basics.Record
import org.vitrivr.cottontail.core.database.ColumnDef
import org.vitrivr.cottontail.core.queries.Digest
import org.vitrivr.cottontail.core.queries.GroupId
import org.vitrivr.cottontail.core.queries.nodes.NodeWithCost
import org.vitrivr.cottontail.core.queries.planning.cost.Cost
import org.vitrivr.cottontail.core.values.types.Types
import org.vitrivr.cottontail.core.values.types.Value

/**
 * This class acts as a level of indirection for [Value]'s used during query planning, optimization and execution.
 *
 * @author Ralph Gasser
 * @version 2.0.0
 */
sealed interface Binding: NodeWithCost {

    /** The [Types] held by this [Binding]. */
    val type: Types<*>

    /** Flag indicating whether [Binding] can return a NULL value. */
    val canBeNull: Boolean

    /** Flag indicating whether [Binding] remains static in the context of a query. */
    val static: Boolean

    /**
     * Obtains the current value for this [Binding].
     *
     * @return [Value]
     */
    context(BindingContext,Record)
    fun getValue(): Value?

    /**
     * Caclulates and returns the [Digest] for this [Binding]
     */
    override fun digest(): Digest = this.hashCode().toLong()

    /** A [Binding] for a literal [Value] without any indirection other than the [Binding] itself. */
    data class Literal(val bindingIndex: Int, override val static: Boolean, override val canBeNull: Boolean, override val type: Types<*>): Binding {
        override val cost: Cost
            get() = Cost.MEMORY_ACCESS
        context(BindingContext,Record)
        override fun getValue(): Value? = this@BindingContext[this]
        context(BindingContext,Record)
        fun update(value: Value?) = this@BindingContext.update(this, value)
        override fun toString(): String = ":$bindingIndex"
    }

    /**
     * A [Binding] for a [Value] referred to by a [ColumnDef].
     *
     * Can only be accessed during query execution.
     */
    data class Column(val column: ColumnDef<*>): Binding  {
        override val type: Types<*>
            get() = this.column.type
        override val canBeNull: Boolean
            get() = this.column.nullable
        override val static: Boolean
            get() = false
        override val cost: Cost
            get() = Cost.MEMORY_ACCESS
        context(BindingContext,Record)
        override fun getValue(): Value? = this@Record[this.column]

        override fun toString(): String = "${this.column.name}"
    }

    /**
     * A [Binding] for a value generated by invocation of a [org.vitrivr.cottontail.core.queries.functions.Function].
     *
     * Can only be accessed during query execution.
     */
    data class Function(val bindingIndex: Int, val function: org.vitrivr.cottontail.core.queries.functions.Function<*>, val arguments: List<Binding>): Binding {
        init {
            this.function.signature.arguments.forEachIndexed {  i, arg ->
                check(arg.type == this.arguments[i].type) { "Type ${this.arguments[i].type} of argument $i is incompatible with function ${function.signature}." }
            }
        }
        override val type: Types<*>
            get() = this.function.signature.returnType
        override val canBeNull: Boolean
            get() = this.arguments.any { it.canBeNull }
        override val cost: Cost
            get() = this.function.cost + this.arguments.map { it.cost }.reduce { c1, c2 -> c1 + c2}
        override val static: Boolean
            get() = false
        val executable: Boolean
            get() = this.function.executable
        context(BindingContext,Record)
        override fun getValue(): Value? = this@BindingContext[this]

        override fun toString(): String = "${this.function.signature}"

        /**
         * Tries to resolve all [ColumnDef] that are required by this [Binding.Function] and possible sub-functions.
         *
         * @return List of required [ColumnDef].
         */
        fun requiredColumns(): List<ColumnDef<*>> = this.arguments.flatMap {
            val columns = mutableSetOf<ColumnDef<*>>()
            when (it) {
                is Column -> columns.add(it.column)
                is Function -> columns.addAll(it.requiredColumns())
                else -> {}
            }
            columns.toList()
        }
    }

    /**
     * A [Binding] for one or multiple [Value]s generated by invocation of a sub-query.
     *
     * Can only be accessed during query execution.
     */
    data class Subquery(val dependsOn: GroupId, val column: ColumnDef<*>): Binding {
        override val type: Types<*>
            get() = this.column.type
        override val canBeNull: Boolean
            get() = this.column.nullable
        override val static: Boolean
            get() = false
        override val cost: Cost
            get() = Cost.ZERO

        context(BindingContext,Record)
        override fun getValue(): Value? = this@BindingContext[this].firstOrNull()

        /**
         * Returns all values held for this [Subquery] in the context of the provided [BindingContext].
         *
         * @return List of [Value]s.
         */
        context(BindingContext,Record)
        fun getValues(): Collection<Value?> = this@BindingContext[this]

        /**
         * Appends a [Value] to this [Subquery] in the provided [BindingContext].
         *
         * @param value The [Value] to append.
         */
        context(BindingContext,Record)
        fun append(value: Value) = this@BindingContext.append(this, value)

        /**
         * Clears all [Value]s bound to this [Subquery] within the provided [BindingContext].
         */
        context(BindingContext,Record)
        fun clear() = this@BindingContext.clear(this)
    }
}